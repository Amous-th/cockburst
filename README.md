# cockburst
一个基于MMAP实现的高性能,可靠的本地持久化队列,可以做到重启JVM,服务器或者强制KILL进程时,
队列里的数据不丢失,下次启动应用时,仍可以继续消费;
### 背景
cockburst很典型的应用场景就是生产者-消费者;为了保证系统的性能,需要异步处理数据,
大多数情况下通过queue作为缓冲队列,JAVA提供了很多队列的实现方式:像List,Vector,
Queue.有线程安全的,非线程安全的,异步的去消费queue;这种作法的弊端就是如果当JVM
重启或者的时候,队列里未消费完的数据就会丢失;通过引入MMAP即可以保证性能问题又可以
保证服务器重启时数据丢失的问题;JAVA进程直接建立起某一段虚拟地址空间和文件对象的关
联映射关系,此时并没有拷贝数据到内存中去。对文件的读写就像在内存中读写一样。这样就
算应用抽风DOWN掉或者重启，操作系统依然会帮你把数据force到磁盘上;性能和完整性都
得到了兼顾;

### 队列设计
队列的存储主要分为两部分,meta文件和data文件;meta用来描述队列消费的偏移量,也就
是offset;data文件作为队列数据真正的存储数据块,目前定的是100M一个数据块,当然,
消费完的数据块也会删除,并不会占用硬盘空间;系统将要记录的数据先行以MMAP方式顺序写，
便直接给业务系统返回调用成功;另起线程将数据force到磁盘上(就算不起线程,操作系统也
会以一定的策略帮你force刷);消费数据时,如果消费成功，更新本地索引文件META。这样既
可以使存储生产数据对业务系统的操作性能影响降到最低，又保证了数据的完整性和安全性。

### 如何使用
使用起来也非常简单方便:
* 在resources目录新建profiler.properties文件,在文件中定义两个属性:
1. 队列文件data的存储目录;
2. 索引文件meta的存储目录;
* 直接调用com.alibaba.profiler.queue.PermanentQueue.offer()或者
com.alibaba.profiler.queue.PermanentQueue.take();其中offer()和
take()的语义与blockqueue的语义是一样的;
* 可参照测试用例使用;

### 性能
本地用自己的AIR测试了一下;100个线程连续写，TPS 50000/s,TP99 1ms ，TP999 8ms

